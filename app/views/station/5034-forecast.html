{% extends "station.html" %}


{% block page_title %}
Irk at Collyhurst Weir - River level - GOV.UK
{% endblock %}


{% block heading %}
River level
<span class="heading-secondary">Irk at Collyhurst Weir</span>
{% endblock %}


{% block message %}
<div class="notice notice-flood-alert">
	<img class="notice-image" src="/public/images/flood-warnings-icon.gif" alt="Flood alert"/>
	<p class="lede">
		<a href="#" class="scroll">View nearby flood warnings</a>
	</p>
</div>
{% endblock %}

{% block riverLevels %}

<section aria-labelledby="levels-heading" role="region">

	<div class="grid-row">

		<div class="column-full">

			<h2 id="levels-heading" class="heading-medium">
				Levels during the last 5 days and forecast for 36 hours
			</h2>     

			<p class="data">
				<i class="icon icon-point"></i>
				<span id="data-type">Latest measure</span> <strong id="data-level">2.42m</strong> at <strong id="data-time">12:00pm on 16 May 2017</strong>.
			</p>

			<!--
			<p id="visualisation-heading" class="font-xsmall">
				<span class="visualisation-heading-measured">Measured levels</span> <span>for the last 5 days</span> <span class="visualisation-heading-forecast">Forecast levels</span> <span>for the next 36 hours
			</p>
			-->

			<div class="visualisation" role="presentation" aria-hidden="true">

				<!--
					If Google Charts available (Javascript, SVG or VML)
					remove hidden class and hidden attribute
				-->

				<div class="visualisation-inner hidden" hidden>

					<figure class="graph" role="presentation" aria-hidden="true">

						<div id="graph"></div>

						<figcaption class="graph-legend">

							<!--
							<div class="data data-level">
								<span class="data-item font-xsmall data-level-item-heading" id="data-type">
									<i class="icon icon-point"></i>
									<span class="data-item-label">
										Latest measured level
									</span>
								</span>
								<span class="data-item bold-small" id="data-details"></span>
							</div>
							-->
							
							<ul>
								<li class="measured">
									<span>Measured level</span>
								</li>
								<li class="forecast">
									<span>Forecast level</span>
								</li>
								<li class="property">
									<span><a href="">Property flooding possible</a></span>
								</li>
								<li class="land">
									<span><a href="">Low-lying land may flood</a></span>
								</li>
								<li class="normal">
									<span>Typical range</span>
								</li>
								<li class="max">
									<span><a href="">Show highest recorded level</a></span>
								</li>
							</ul>

						</figcaption>

					</figure>

				</div>

				<!-- End dynamic render -->

				<!--
					If Google Charts available add class visuallyhidden
				-->

				<div class="visualisation-table">

					<div class="panel panel-border-narrow" aria-hidden="true">
						<p>
							A graph is available with JavaScript enabled and a modern browser
						</p>
					</div>

					<table class="table-levels" aria-labelledby="visualisation-heading">
						<thead>
							<tr>
								<th scope="col">Time</th> <!-- role="columnheader" ? -->
								<th scope="col" class="numeric">
									Level (<abbr title="Metres">m</abbr>)
								</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<th scope="col" colspan="2">
									<time datetime="2017-01-06T09:00+00:00">
										Friday 6 January	
									</time>
								</th>
							</tr>
							<tr>
								<td scope="row">
									<time datetime="2017-01-06T09:00+00:00">
										9:00am	
									</time>
								</td>
								<td class="numeric">
									0.43
									<span class="error">
										Error
									</span>
								</td>
							</tr>
						</tbody>
						<tbody>
							<tr>
								<td scope="row">
									<time datetime="2017-01-06T09:15+00:00">
										9:15am	
									</time>
								</td>
								<td class="numeric">
									0.48
								</td>
							</tr>	
						</tbody>
						<tbody>
							<tr>
								<th scope="col" colspan="2">
									<time datetime="2017-01-06T09:00+00:00">
										Saturday 7 January	
									</time>
								</th>
							</tr>
							<tr>
								<td scope="row">
									<time datetime="2017-01-06T09:00+00:00">
										9:00am
										<em class="forecast">
											(Latest recorded)
										</em>		
									</time>
								</td>
								<td class="numeric">
									0.59
									<span class="error">
										Error
									</span>
								</td>
							</tr>
						</tbody>
						<tbody>
							<tr>
								<td scope="row">
									<time datetime="2017-01-06T09:30+00:00">
										9:30am
										<em class="forecast">
											(Forecast)
										</em>	
									</time>
								</td>
								<td class="numeric">
									0.65
								</td>
							</tr>	
							<tr>
								<td scope="row">
									<time datetime="2017-01-06T09:45+00:00">
										9:45am
										<em class="forecast">
											(Highest forecast)
										</em>	
									</time>
								</td>
								<td class="numeric">
									0.63
								</td>
							</tr>
						</tbody>
					</table>

				</div>

				<!--
					End Google charts available
				-->

			</div>

		</div>

	</div>

	<div class="grid-row">
		
		<div class="column-two-thirds">
			
			<details>
				
				  <summary><span class="summary">How river levels are measured and forecast</span></summary>
				
				  <div class="panel panel-border-narrow">
				
					<p>For most river levels the data we collect is fed into this service once or twice a day. We often increase this frequency whenever there is a greater risk of flooding.</p>
					<p>Forecast levels are derived from automated models. These are most accurate for the next 6 hours.</p>
						
				  </div>
				
			</details>
			
		</div>

	</div>
	

</section>


<!-- Remove -->
<script>
	var visualisation = document.getElementsByClassName('visualisation')
	for (i=0; i<visualisation.length; i++){
		var table = visualisation[i].getElementsByClassName('visualisation-table')[0]
		var inner = visualisation[i].getElementsByClassName('visualisation-inner')[0]
		table.className += ' visuallyhidden'
		inner.className = 'visualisation-inner'
		inner.removeAttribute('hidden')
	}
</script>
<!-- End remove -->

{% endblock %}

{% block nearby_areas %}
<h2 class="heading-medium" id="nearby-areas">What effect could these levels have on nearby areas?</h2>
<h3 class="heading-small">Typical range at this location</h3>
<p>0.75m to 2.70m</p>
<h3 class="heading-small">Low-lying land may flood above</h3>
<p>2.70m <a href="">target area name</a></p>
<h3 class="heading-small">Property flooding possible above</h3>
<ul class="list">
<li>4.20m <a href="">target area name</a></li>
<li>4.35m <a href="">target area name</a></li>
</ul>
<h3 class="heading-small">Highest level recorded at this location</h3>
<p>5.10m on 6 December 2015</p>
{% endblock %}

{% block body_end %}
<!-- GOV.UK elements redirect -->
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

	var Chart = (function(window,d3) {

		const yExtension = 0.4,
			windowBreakPoint = 640,
			svgBreakPoint = 576,
			xCutOff = 9,
			toolTipBgPath = 'm0,0 l124,0 l0,62 l-52,0 l-10,15 l-10,-15 l-52,0 l0,-62',
			toolTipBgPathLeft = 'm0,0 l124,0 l0,62 l-94,0 l-25,15 l5,-15 l-10,0 l0,-62',
			toolTipBgPathRight = 'm0,0 l124,0 l0,62 l-10,0 l5,15 l-25,-15 l-94,0 l0,-62'

		var svg,
			data,
			x, y, 
			xAxis, yAxis, 
			dim, 
			chartWrapper, 
			line, area, path, 
			margin = {}, 
			locator, locatorX, locatorY,
			toolTip, toolTipX, toolTipY,
			now, timeX,
			width, height,
			parentWidth, parentHeight,
			hasObserved = false, hasForecast = false, hasHighest = false, hasWarning = false, hasAlert = false,
			parseTime, parseDate,
			latestLevel, latestDate,
			dataPoint, dataPointLatest


		d3.json('/public/javascripts/json/shrewsbury-fixed-error-band.json', init)

		function init(json) {

			data = json

			// Setup array to combine observed and forecast points
			// and identify startPoint for locator 
			lines = []
			if (data.observed) {
				lines = lines.concat(data.observed)
				dataPoint = JSON.parse(JSON.stringify(data.observed[data.observed.length-1]))
				hasObserved = true
			}
			if (data.forecast) {
				lines = lines.concat(data.forecast)
				dataPoint = JSON.parse(JSON.stringify(data.forecast[0]))
				hasForecast = true
			}

			// Set dataPointLatest
			dataPointLatest = JSON.parse(JSON.stringify(dataPoint))
		
			// Initialize scales
			xExtent = d3.extent(lines, function(d,i) { return new Date(d.date) })
			yExtent = d3.extent(lines, function(d,i) { return d.level })

			// Set Y range to highest and lowest values from the data
			yRange = [yExtent[0],yExtent[1]]
			if (data.highest) { 
				yRange.push(data.highest)
				hasHighest = true
			}
			if (data.warning) { 
				yRange.push(data.warning)
				hasWarning = true
			}
			if (data.alert) { 
				yRange.push(data.alert)
				hasAlert = true
			}
			yExtent[0] = Math.min.apply(Math,yRange)
			yExtent[1] = Math.max.apply(Math,yRange)

			// Add margin to bottom of Y Axis
			yExtent[0] = ((yExtent[0] * 100) - (yExtension * 100))/100

			// Add margin to top of Y Axis
			yExtent[1] = ((yExtent[1] * 100) + (yExtension * 100))/100

			// Setup scales
			x = d3.time.scale().domain(xExtent)
			y = d3.scale.linear().domain(yExtent)

			// Bisect date
			bisectDate = d3.bisector(function(d) { return new Date(d.date) }).left

			// Initialize axis
			xAxis = d3.svg.axis().orient('bottom').outerTickSize(0)
			yAxis = d3.svg.axis().orient('left').ticks(5).tickFormat(function(d) { 
				return parseFloat(d).toFixed(1) + 'm'
			}).outerTickSize(0)

			// Area generator
			area = d3.svg.area()
			.interpolate('basis')
			.x(function(d) { return x(new Date(d.date)) })
			.y0(function(d) { return height })
			.y1(function(d) { return y(d.level) })

			// Line generator
			line = d3.svg.line()
			.interpolate('basis')
			.x(function(d) { return x(new Date(d.date)) })
			.y(function(d) { return y(d.level) })

			// Initialize svg
			svg = d3.select('#graph').append('svg').style('pointer-events', 'none')
			chartWrapper = svg.append('g').style('pointer-events', 'all')
			chartWrapper.append('g').classed('thresholds', true)
			chartWrapper.append('g').classed('y grid', true)
			chartWrapper.append('g').classed('x grid', true)
			chartWrapper.append('g').classed('x axis', true)
			chartWrapper.append('g').classed('y axis', true)
			if (hasObserved) {
				chartWrapper.append('g').classed('observed observed-focus', true)
				//observedArea = svg.select('.observed').append('path').datum(data.observed).classed('observed-area', true)
				observed = svg.select('.observed').append('path').datum(data.observed).classed('observed-line', true)
			}
			normalBand = svg.select('.thresholds').append('rect').classed('normal-band', true)
			if (hasAlert) {
				alertBand = svg.select('.thresholds').append('rect').classed('alert-band', true)
			}
			if (hasWarning) {
				warningBand = svg.select('.thresholds').append('rect').classed('warning-band', true)
				//svg.select('.thresholds').append('line').classed('warning', true);
			}
			if (hasForecast) {
				chartWrapper.append('g').classed('forecast', true)
				forecast = svg.select('.forecast').append('path').datum(data.forecast).classed('forecast-line', true)
			}
			if (hasHighest) {
				svg.select('.thresholds').append('line').classed('highest', true)
			}
			
			// Add timeline
			if(data.now) {
				chartWrapper.append('g').classed('time', true)
				now = svg.select('.time')
				svg.select('.time').append('line').classed('time-line', true)
				svg.select('.time').append('text').classed('time-now', true).text('Now')
			}

			// Add locator
			locator = chartWrapper.append('g').classed('locator', true)
			locatorPoint = locator.append('circle').attr('r', 4.5).classed('locator-point', true)
			
			// Add tooltip
			toolTip = chartWrapper.append('g').classed('tool-tip', true).classed('tool-tip tool-tip-hidden', true)
			toolTipBg = toolTip.append('path').attr('d',toolTipBgPath).classed('tool-tip-bg', true)
			toolTipLevel = toolTip.append('text').attr({'x': 10,'y':27}).classed('tool-tip-level', true).text('Level')
			toolTipDate = toolTip.append('text').attr({'x': 10,'y':47}).classed('tool-tip-date', true).text('Date')

			// Add click event
			chartWrapper.on('click', click)

			// Render the chart
			render()

		}

		function render() {

			updateDimensions()

			// Update svg elements to new dimensions
			chartWrapper.attr('transform', 'translate(' + (margin.left + margin.right) + ',' + 0 + ')')

			// Update the axis and line
			xAxis.scale(x)
			yAxis.scale(y)
			svg.select('.x.axis').attr('transform', 'translate(0,' + height + ')').call(xAxis)
			svg.select('.y.axis').call(yAxis)

			// Update grid lines
			/*
			svg.select('.x.grid')
			.attr('transform', 'translate(0,' + height + ')')
			.call(d3.svg.axis()
				.scale(x)
				.orient('bottom')
				.ticks(d3.time.day,1)
				.tickSize(-height, 0, 0)
				.tickFormat('')
			)
			svg.select('.y.grid')
			.attr('transform', 'translate(0,' + 0 + ')')
			.call(d3.svg.axis()
				.scale(y)
				.orient('left')
				.ticks(5)
				.tickSize(-width, 0, 0)
				.tickFormat('')
			)
			*/

			// Update thresholds
			if (hasHighest) {
				svg.select('.highest').attr('transform', 'translate(0,' + y(data.highest) + ')').attr('x2', x(xExtent[1])).attr('y2', 0)
			}
			if (hasWarning) {
				warningBand.attr({'x':x(xExtent[0]),'y':y(yExtent[1]),'width':x(xExtent[1]),'height':y(data.warning)})
			}
			if (hasAlert) {
				alertBand.attr({'x':x(xExtent[0]),'y':y(yExtent[1]),'width':x(xExtent[1]),'height':y(data.alert)})
			}
			normalBand.attr({'x':x(xExtent[0]),'y':y(yExtent[1]),'width':x(xExtent[1]),'height':y(yExtent[0])})

			// Update time line
			if (data.now) {
				timeX = Math.floor(x(new Date(data.now)))
				svg.select('.time-line').attr('y1', 0).attr('y2', height)
				svg.select('.time-now').attr('x', -17).attr('y', -6)
				now.attr('y1', 0).attr('y2', height)	
					.attr('transform', 'translate(' + timeX + ',0)')				
				// Add 'today' class to x axis tick
				svg.selectAll('.x .tick')
					.filter(function(d){ 
						return new Date(d).getDay() == new Date(data.now).getDay() && new Date(d).getUTCHours() == 12
					})
					.attr('class', 'tick tick-today')
			}

			// Draw lines and areas
			if (hasObserved) {
				observed.attr('d', line)
			}
			if (hasForecast) {
				forecast.attr('d', line)
			}

			// Set level and date formats
			parseTime = d3.time.format.utc('%-I:%M%p')
			parseDate = d3.time.format.utc('%e %b %Y')
			parseDateShort = d3.time.format.utc('%e %b')

			// Set locator position
			locator.attr('transform', 'translate(' + locatorX + ',' + locatorY + ')')

			// Set tooltip position 
			toolTip.attr('transform', 'translate(' + toolTipX + ',' + toolTipY + ')')

		}

		function updateDimensions() {

			margin.top = 25
			margin.bottom = 25
			margin.left = 18
			margin.right = 18

			xCutOffLeft = d3.time.hour.offset(xExtent[0], + xCutOff).getTime()
			xCutOffRight = d3.time.hour.offset(xExtent[1], - xCutOff).getTime()

			// Get dimensions based on parent size
			parentWidth = Math.floor(d3.select('#graph').node().getBoundingClientRect().width)
			parentHeight = Math.floor(d3.select('#graph').node().getBoundingClientRect().height)

			// Mobile first
			xAxis.ticks(d3.time.hour.utc, 12).tickFormat(function(d) {
				if (d.getUTCHours() == 12 & d >= xCutOffLeft & d <= xCutOffRight) {
					formatter = d3.time.format('%-e/%-m')
					return formatter(d)
				} else {
					return null
				}
			})

			// Greater than window or svg breakpoint
			if(window.innerWidth > windowBreakPoint && parentWidth > svgBreakPoint) {
				xAxis.ticks(d3.time.hour.utc, 12).tickFormat(function(d) {
					if (d.getUTCHours() == 12 & d.getTime() >= xCutOffLeft & d.getTime() <= xCutOffRight) {
						formatter = d3.time.format('%a, %e %b')
						return formatter(d)
					} else {
						return null
					}
				})
				margin.left = 21
				margin.right = 21
			}
			width = parentWidth - margin.left - margin.right
			height = parentHeight - margin.top - margin.bottom

			// Update x and y scales to new dimensions
			x.range([0, width])
			y.range([height, 0])

			// Update locator position
			locatorX = Math.floor(x(new Date(dataPoint.date)))
			locatorY = Math.floor(y(dataPoint.level))

			// Update tooltip position
			updateToolTipPosition()

		}

		function updateToolTipPosition() {

			if (locatorX - toolTipBg.node().getBBox().width < 0) {
				// Tool tip on the left
				toolTipX = locatorX + 5
				toolTipBg.attr('d',toolTipBgPathLeft)
			} else if (locatorX + toolTipBg.node().getBBox().width > width) {
				// Tool tip on the right			
				toolTipX = locatorX - toolTipBg.node().getBBox().width - 5
				toolTipBg.attr('d',toolTipBgPathRight)
			} else {
				// Tool tip in the middle
				toolTipX = locatorX - toolTipBg.node().getBBox().width / 2
				toolTipBg.attr('d',toolTipBgPath)
			}
			toolTipY = locatorY - toolTipBg.node().getBBox().height - 8

		}

		function click() {

			var x0 = x.invert(d3.mouse(this)[0]),
			i = bisectDate(lines, x0, 1)
			d0 = lines[i - 1]
			d1 = lines[i]

			d = x0 - new Date(d0.date) > new Date(d1.date) - x0 ? d1 : d0
			dataPoint.date = d.date
			dataPoint.level = d.level

			locatorX = Math.floor(x(new Date(dataPoint.date)))
			locatorY = Math.floor(y(dataPoint.level))
			latestX = Math.floor(x(new Date(dataPointLatest.date)))

			// Update figcaption data
			if (locatorX > latestX) {
				locatorPoint.classed('locator-point-forecast', true)
				svg.select('.forecast').classed('forecast-focus', true)
				svg.select('.observed').classed('observed-focus', false)
				d3.select('#data-type').html('Forecast level')
				d3.select('.data').classed('data-forecast', true)
			} else {
				locatorPoint.classed('locator-point-forecast', false)
				svg.select('.forecast').classed('forecast-focus', false)
				svg.select('.observed').classed('observed-focus', true)
				d3.select('#data-type').html('Previous level')
				d3.select('.data').classed('data-forecast', false)
			}
			if (locatorX == latestX) {
				d3.select('#data-type').html('Latest measure')
			}

			// Update graph caption
			d3.select('#data-time').html(
				parseTime(new Date(dataPoint.date)).toLowerCase()
				+ ' on '
				+ parseDate(new Date(dataPoint.date)))
			d3.select('#data-level').html(
				dataPoint.level + 'm')

			// Update locator point
			locator.attr('transform', 'translate(' + locatorX + ',' + locatorY + ')')

			// Update tooltip content, position and visibiliy
			updateToolTipPosition()

			toolTipY = locatorY - toolTipBg.node().getBBox().height - 10
			toolTipLevel.html(dataPoint.level + 'm')
			toolTipDate.html(
				parseTime(new Date(dataPoint.date)).toLowerCase()
				+ ', '
				+ parseDateShort(new Date(dataPoint.date)
			))
			toolTip.attr('transform', 'translate(' + toolTipX + ',' + toolTipY + ')').classed('tool-tip-hidden', false)

		}

		return {

			render : render

		}

	})(window,d3)

	window.addEventListener('resize', Chart.render)

</script>
{% include "partials/scripts.html" %}
{% endblock %}